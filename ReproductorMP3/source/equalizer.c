/***************************************************************************/ /**
   @file     +Nombre del archivo (ej: template.c)+
   @brief    +Descripcion del archivo+
   @author   Grupo 3
  ******************************************************************************/

/*******************************************************************************
 * INCLUDE HEADER FILES
 ******************************************************************************/

#include <arm_math.h>
#include "equalizer.h"

/*******************************************************************************
 * CONSTANT AND MACRO DEFINITIONS USING #DEFINE
 ******************************************************************************/

#define PEAKGAIN (12)	// in dB
#define NOTCHGAIN (-12) // in dB
#define GAINSTEP (3)	// in dB
// TODO: ajustar valor de MAX_POWER_VALUE
#define MAX_POWER_VALUE (32768 / 4)

/*******************************************************************************
 * ENUMERATIONS AND STRUCTURES AND TYPEDEFS
 ******************************************************************************/

/*******************************************************************************
 * VARIABLES WITH GLOBAL SCOPE
 ******************************************************************************/
float blackmanWindow[1024] = {0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002, 0.0003, 0.0003, 0.0004, 0.0004, 0.0005, 0.0006, 0.0007, 0.0007, 0.0008, 0.0009, 0.0010, 0.0012, 0.0013, 0.0014, 0.0016, 0.0017, 0.0019, 0.0020, 0.0022, 0.0024, 0.0026, 0.0028, 0.0031, 0.0033, 0.0036, 0.0039, 0.0042, 0.0045, 0.0048, 0.0051, 0.0055, 0.0059, 0.0063, 0.0067, 0.0071, 0.0076, 0.0081, 0.0086, 0.0091, 0.0097, 0.0103, 0.0109, 0.0116, 0.0122, 0.0129, 0.0137, 0.0145, 0.0153, 0.0161, 0.0170, 0.0179, 0.0188, 0.0198, 0.0208, 0.0219, 0.0230, 0.0241, 0.0253, 0.0265, 0.0278, 0.0291, 0.0305, 0.0319, 0.0334, 0.0349, 0.0365, 0.0381, 0.0398, 0.0415, 0.0433, 0.0452, 0.0471, 0.0490, 0.0510, 0.0531, 0.0553, 0.0575, 0.0598, 0.0621, 0.0645, 0.0670, 0.0695, 0.0722, 0.0748, 0.0776, 0.0804, 0.0833, 0.0863, 0.0894, 0.0925, 0.0957, 0.0990, 0.1023, 0.1058, 0.1093, 0.1129, 0.1166, 0.1203, 0.1242, 0.1281, 0.1321, 0.1362, 0.1404, 0.1446, 0.1490, 0.1534, 0.1579, 0.1625, 0.1672, 0.1720, 0.1769, 0.1818, 0.1868, 0.1920, 0.1972, 0.2025, 0.2078, 0.2133, 0.2189, 0.2245, 0.2302, 0.2360, 0.2419, 0.2479, 0.2540, 0.2601, 0.2663, 0.2726, 0.2790, 0.2855, 0.2920, 0.2986, 0.3053, 0.3121, 0.3189, 0.3258, 0.3328, 0.3399, 0.3470, 0.3542, 0.3615, 0.3688, 0.3762, 0.3836, 0.3912, 0.3987, 0.4063, 0.4140, 0.4218, 0.4295, 0.4374, 0.4452, 0.4532, 0.4611, 0.4691, 0.4772, 0.4852, 0.4934, 0.5015, 0.5097, 0.5178, 0.5261, 0.5343, 0.5425, 0.5508, 0.5591, 0.5674, 0.5756, 0.5839, 0.5922, 0.6005, 0.6088, 0.6171, 0.6254, 0.6336, 0.6419, 0.6501, 0.6583, 0.6664, 0.6746, 0.6827, 0.6907, 0.6988, 0.7068, 0.7147, 0.7226, 0.7304, 0.7382, 0.7460, 0.7536, 0.7612, 0.7688, 0.7762, 0.7836, 0.7909, 0.7982, 0.8053, 0.8124, 0.8194, 0.8262, 0.8330, 0.8397, 0.8463, 0.8528, 0.8592, 0.8654, 0.8716, 0.8776, 0.8836, 0.8894, 0.8950, 0.9006, 0.9060, 0.9113, 0.9165, 0.9215, 0.9264, 0.9311, 0.9357, 0.9402, 0.9445, 0.9487, 0.9527, 0.9566, 0.9603, 0.9638, 0.9672, 0.9704, 0.9735, 0.9764, 0.9792, 0.9817, 0.9842, 0.9864, 0.9885, 0.9904, 0.9921, 0.9937, 0.9951, 0.9963, 0.9974, 0.9982, 0.9989, 0.9995, 0.9998, 1.0000, 1.0000, 0.9998, 0.9995, 0.9989, 0.9982, 0.9974, 0.9963, 0.9951, 0.9937, 0.9921, 0.9904, 0.9885, 0.9864, 0.9842, 0.9817, 0.9792, 0.9764, 0.9735, 0.9704, 0.9672, 0.9638, 0.9603, 0.9566, 0.9527, 0.9487, 0.9445, 0.9402, 0.9357, 0.9311, 0.9264, 0.9215, 0.9165, 0.9113, 0.9060, 0.9006, 0.8950, 0.8894, 0.8836, 0.8776, 0.8716, 0.8654, 0.8592, 0.8528, 0.8463, 0.8397, 0.8330, 0.8262, 0.8194, 0.8124, 0.8053, 0.7982, 0.7909, 0.7836, 0.7762, 0.7688, 0.7612, 0.7536, 0.7460, 0.7382, 0.7304, 0.7226, 0.7147, 0.7068, 0.6988, 0.6907, 0.6827, 0.6746, 0.6664, 0.6583, 0.6501, 0.6419, 0.6336, 0.6254, 0.6171, 0.6088, 0.6005, 0.5922, 0.5839, 0.5756, 0.5674, 0.5591, 0.5508, 0.5425, 0.5343, 0.5261, 0.5178, 0.5097, 0.5015, 0.4934, 0.4852, 0.4772, 0.4691, 0.4611, 0.4532, 0.4452, 0.4374, 0.4295, 0.4218, 0.4140, 0.4063, 0.3987, 0.3912, 0.3836, 0.3762, 0.3688, 0.3615, 0.3542, 0.3470, 0.3399, 0.3328, 0.3258, 0.3189, 0.3121, 0.3053, 0.2986, 0.2920, 0.2855, 0.2790, 0.2726, 0.2663, 0.2601, 0.2540, 0.2479, 0.2419, 0.2360, 0.2302, 0.2245, 0.2189, 0.2133, 0.2078, 0.2025, 0.1972, 0.1920, 0.1868, 0.1818, 0.1769, 0.1720, 0.1672, 0.1625, 0.1579, 0.1534, 0.1490, 0.1446, 0.1404, 0.1362, 0.1321, 0.1281, 0.1242, 0.1203, 0.1166, 0.1129, 0.1093, 0.1058, 0.1023, 0.0990, 0.0957, 0.0925, 0.0894, 0.0863, 0.0833, 0.0804, 0.0776, 0.0748, 0.0722, 0.0695, 0.0670, 0.0645, 0.0621, 0.0598, 0.0575, 0.0553, 0.0531, 0.0510, 0.0490, 0.0471, 0.0452, 0.0433, 0.0415, 0.0398, 0.0381, 0.0365, 0.0349, 0.0334, 0.0319, 0.0305, 0.0291, 0.0278, 0.0265, 0.0253, 0.0241, 0.0230, 0.0219, 0.0208, 0.0198, 0.0188, 0.0179, 0.0170, 0.0161, 0.0153, 0.0145, 0.0137, 0.0129, 0.0122, 0.0116, 0.0109, 0.0103, 0.0097, 0.0091, 0.0086, 0.0081, 0.0076, 0.0071, 0.0067, 0.0063, 0.0059, 0.0055, 0.0051, 0.0048, 0.0045, 0.0042, 0.0039, 0.0036, 0.0033, 0.0031, 0.0028, 0.0026, 0.0024, 0.0022, 0.0020, 0.0019, 0.0017, 0.0016, 0.0014, 0.0013, 0.0012, 0.0010, 0.0009, 0.0008, 0.0007, 0.0007, 0.0006, 0.0005, 0.0004, 0.0004, 0.0003, 0.0003, 0.0002, 0.0002, 0.0002, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001};
static float currentGains[BANDS];

static float *presetSelected;
static float flatConfig[BANDS] = {0, 0, 0, 0, 0, 0, 0, 0};
static float bassConfig[BANDS] = {4, 3, 2, 0, 0, 0, 0, 0};
static float rockConfig[BANDS] = {5, 4, 2, 0, -1, 1, 3, 4};
static float popConfig[BANDS] = {-2, -1, 4, 4, 4, 2, -1, -2};

static const float filterQ[BANDS] = {1.23f, 1.23f, 1.3f, 1.3f, 1.23f, 1.4f, 1.39f, 1.49f};

// Filter parameters
static const uint16_t centerFreqs[BANDS] = {34, 80, 190, 450, 1100, 2500, 6000, 14200}; // In Hz

static float bandPower[BANDS] = {0};
/*******************************************************************************
 * FUNCTION PROTOTYPES FOR PRIVATE FUNCTIONS WITH FILE LEVEL SCOPE
 ******************************************************************************/

/*******************************************************************************
 * ROM CONST VARIABLES WITH FILE LEVEL SCOPE
 ******************************************************************************/

/*******************************************************************************
 * STATIC VARIABLES AND CONST VARIABLES WITH FILE LEVEL SCOPE
 ******************************************************************************/
static arm_rfft_fast_instance_f32 S;
/*******************************************************************************
 *******************************************************************************
			GLOBAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/

void initEqualizer()
{
	initFilters();
}

void changeGain(uint8_t filterID, bool direction)
{

	int currGain = (int)getGain(filterID);

	if (direction == INCREASE && currGain + GAINSTEP <= PEAKGAIN)
	{
		changeGain(filterID, currGain + GAINSTEP);
	}
	else if (direction == DECREASE && currGain - GAINSTEP >= NOTCHGAIN)
	{
		changeGain(filterID, currGain - GAINSTEP);
	}
}

void processEqualizer(float *in, float *out, uint32_t blockSize)
{
	computeFilters(in, out, blockSize);
}

void changePreset(uint8_t preset)
{

	switch (preset)
	{
	case Rock:
		presetSelected = rockConfig;
		break;
	case Pop:
		presetSelected = popConfig;
		break;
	case Flat:
		presetSelected = flatConfig;
		break;
	case Bass:
		presetSelected = bassConfig;
		break;
	}

	for (int i = 0; i < BANDS; i++)
	{
		currentGains[i] = presetSelected[i];
	}

	setGain(currentGains);
}

void analizeBlock(float *data, uint32_t datalen, float samprate)
{
	// get the power of two that fits the data size
	static float pOut[2048];
	static float pOutMod[1024];
	uint32_t power = 0x80000000U >> __builtin_clz(datalen);

	for (size_t i = 0; i < power; i++)
	{
		data[i] *= blackmanWindow[i * 1024 / power];
	}

	if (power < 32)
	{
		return;
	}
	arm_rfft_fast_init_f32(&S, power);
	arm_rfft_fast_f32(&S, data, pOut, 0);
	arm_cmplx_mag_f32(pOut, pOutMod, power / 2);

	memset(bandPower, 0, sizeof(bandPower));

	uint32_t j = 0;
	uint32_t binCounter[BANDS] = {0};

	for (size_t i = 0; i < power / 2; i++)
	{
		if (samprate / power * (i + 1) > 8158.27f)
		{
			j = 7;
		}
		else if (samprate / power * (i + 1) > 3392.86f)
		{
			j = 6;
		}
		else if (samprate / power * (i + 1) > 1547.15f)
		{
			j = 5;
		}
		else if (samprate / power * (i + 1) > 623.0f)
		{
			j = 4;
		}
		else if (samprate / power * (i + 1) > 263.0f)
		{
			j = 3;
		}
		else if (samprate / power * (i + 1) > 112.52f)
		{
			j = 2;
		}
		else if (samprate / power * (i + 1) > 47.8f)
		{
			j = 1;
		}
		binCounter[j]++;
		bandPower[j] += pOutMod[i];
	}

	for (int i = 0; i < BANDS; i++)
	{
		bandPower[i] = 20 * log10f(bandPower[i] / ((binCounter[i]) * MAX_POWER_VALUE));
	}
}

void analisis2vumeter(uint8_t vumeterDataout[8])
{
	for (int i = 0; i < BANDS; i++)
	{
		vumeterDataout[i] = (uint8_t)((bandPower[i] > -30.0f) ? (bandPower[i] + 30.0f) / 65.0f * 8.0f : 0);
	}
}
/*******************************************************************************
 *******************************************************************************
			LOCAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/
